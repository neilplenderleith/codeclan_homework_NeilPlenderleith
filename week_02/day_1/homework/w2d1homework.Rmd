---
title: "R Notebook"
output: html_notebook
---


```{r}
library(tidyverse)
library(janitor)
```


# 1.1 Joins

# Question 1

Read in all 4 credit card transaction datasets and clean column names.


```{r}

card_base <- read_csv("../data/CardBase.csv")
customer_base <- read_csv("../data/CustomerBase.csv")
fraud_base <- read_csv("../data/FraudBase.csv")
transaction_base <- read_csv("../data/TransactionBase.csv")

# following cleans up the column names with _ and lower case
card_base <- clean_names(card_base, case = "snake")
customer_base <-clean_names(customer_base, case = "snake")
fraud_base <- clean_names(fraud_base, case = "snake")
transaction_base <- clean_names(transaction_base, case = "snake")

```

# Question 2

Join the data containing card details and customer details by customer id, so that 
all records of card details and any matching records in customer details are kept. 
Before you run the code, think about how many rows you expect to see after joining.

```{r}

left_join(card_base, customer_base)

# expected it to return 500 rows - the size of card data(card_base)

```


# Question 3

Join the data containing fraud details with transaction details so all rows of both 
tables are kept. What does the resulting row number tell you?

```{r}

full_join(transaction_base, fraud_base)
 

# row number is 10000, the size of transaction data. As fraud data is only 109 rows 
# these all must match a row in transaction data. Quick look at the data shows this 
# to be true and it makes sense - a small fraction of transactions would be flagged 
# for fraud purposes. 

```


# Question 4

Join the data containing card details with transaction details so rows from the first 
which have matching ones in the second are returned, but only return rows in the first 
table once.

```{r}
# not clear which way round you want it joined, pretty much just returns the whole dataset either way???
# maybe i'm not understanding the question

semi_join(card_base, transaction_base, by = c("card_number" = "credit_card_id"))

# semi_join(transaction_base, card_base,  by = c("credit_card_id" = "card_number"))



# I've tried it both ways and either way it simply returns the whole dataset on the left
# of the join argument. this does show that all credit cards have at least one transaction 
# and also all the credit cards in the transaction dataset are in the credit card dataset
```


# 1.2 tidyr
# Questions 5&6

Read in hat_observations and separate observation into two columns, hat_colour and 
hat_type.

Question 6

Unite day, month, and year columns into a column called date using a suitable separator. 
Then find the date where the most berets were observed.

```{r}

hat_observations <- read_csv("../data/hat_observations.csv")

hat_observations %>% 
  separate(observation, c("hat_colour", "hat_type"), sep = ",") %>% 
  unite(date, c("day", "month", "year"), sep = ":") %>% 
  filter(hat_type == "beret") %>% 
  slice_max(observation_count, n = 1) %>% 
  pull(date)

# should have grouped_by date after the filter then summarised by sum of observations

# date is 18/6/2018, 9 white berets were seen
```



#2 Extension 

# Question 1 Joins

Can you join all 4 datasets together so that youâ€™re left with a dataset that looks 
like below with 109 rows and 12 columns?

```{r}
# Looks like the order from the picture is card, customer, transaction then fraud

left_join(card_base, customer_base) %>% 
  left_join(transaction_base, by = c("card_number" = "credit_card_id")) %>% 
  right_join(fraud_base)


# playing around with different joins yields the same dataset

```




# Question 2 tidyr

Read in exam_scores and transform it into long format with two new columns exam_question 
and score. Then, using separate and select, remove superfluous information from the 
values in exam_question

```{r}

exam_scores <- read_csv("../data/exam_scores.csv")

exam_scores %>% 
  pivot_longer(cols = starts_with("exam"),
               names_to = "exam_question",
               values_to = "score") %>% 
  separate(col = exam_question, c("exam", "exam_question"), sep = "_" ) %>% 
  select(id, exam_question, score)

```

